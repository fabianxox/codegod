ou are given a 2D integer array intervals[][] of length n, where each intervals[i] = [start, end] represents a closed interval (i.e., all integers from start to end, inclusive). You are also given an integer k. An integer is called Powerful if it appears in at least k intervals. Find the maximum Powerful Integer.

Note: If no integer occurs at least k times return -1.

Examples:

Input : n = 3, intervals[][] = [[1, 3], [4, 6], [3, 4]], k = 2
Output: 4
Explanation: Integers 3 and 4 appear in 2 intervals. The maximum is 4.
Input : n = 4, intervals[][] = [[1, 4], [12, 45], [3, 8], [10, 12]], k = 3
Output: -1
Explanation: No integer appears in at least 3 intervals.
Input : n = 5, intervals[][] = [[16, 21], [5, 8], [12, 17], [17, 29], [9, 24]], k = 3
Output: 21
Explanation: Integers 16, 17, 18, 19, 20 and 21 appear in at least 3 intervals. The maximum is 21.

-----

brute force:

class Solution {
    public int powerfulInteger(int[][] intervals, int k) {
        // code here
        TreeMap<Integer, Integer>tm=new TreeMap<>();
        
        for(int i=0;i<intervals.length; i++){
            int ind=0;
            int[]arr=new int[2];
            for(int j=0; j<2; j++){
                arr[ind++]=intervals[i][j];
            }
            freq(arr,tm);
        }
        
        int max=0;
        
        for(Map.Entry<Integer, Integer>entry:tm.entrySet()){
            if(entry.getValue()>=k){
                int num=entry.getKey();
                if(num>max) max=num;
            } 
        }
        
        if(max==0) return -1;
        return max;
    }
    
    public static void freq(int[]arr,TreeMap<Integer, Integer>tm){
        int s=arr[0],e=arr[1];
        
        for(int i=s; i<=e; i++){
            tm.put(i, tm.getOrDefault(i,0)+1);
        }
    }
}

-------

optimised:

class Solution {
    public int powerfulInteger(int[][] intervals, int k) {
        TreeMap<Integer, Integer> hm = new TreeMap<>();
        
        for (int[] arr : intervals) {
            int s = arr[0];
            int e = arr[1];
            
            hm.put(s, hm.getOrDefault(s, 0) + 1);
            hm.put(e + 1, hm.getOrDefault(e + 1, 0) - 1);
        }
        
        int sum = 0;
        int result = -1;
        
        for (Map.Entry<Integer, Integer> entry : hm.entrySet()) {
            int num = entry.getKey();
             
            if (sum >= k) {
                result = num - 1;
            }
sum += entry.getValue();
           
        }

        return result;
    }
}
